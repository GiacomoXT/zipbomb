B <- 36

# Closed-form formula for sum(nchar(filename_for_index(0..(n-1)))), the sum of
# the first n filenames generated by filename_for_index.
#
# First, pretend like filename_for_index generates a zero-length
# filename at index 0, and shift the other indices by 1. This doesn't
# affect the sum of lengths, and makes the formula more regular. Now, of
# the first n filenames, all but 1 are at least 1 byte long, all but
# 36+1 are at least 2 bytes long, all but 36²+36+1 are at least 3 bytes
# long, and so on. In general, for a length i, all but 36^(i-1)+...+1 =
# (36^i-1)/35 (a base-36 repunit) filenames are at least i bytes long.
# The greatest value of i that does not exceed the length of the nth
# filename is
#   d = floor(log_36(n/(36/35)))
# For each value of i, we add 1 byte for each filename that is at least
# i bytes long.
#   Σ_i=0…d n - (36^i-1)/35
#   = dn - Σ_i=0…d (36^i-1)/35
#   = dn - ((36^d-1)*36/35² - d/35)
# where the last equality comes from adapting a formula for the sum of
# base-10 repunits: https://oeis.org/A014824.
sum_filename_lengths <- function(n) {
	n <- n + 1 # Shift by 1 index for a fictitious zero-length filename.
	B1 <- B - 1
	# Length of the longest base-B repunit not greater than n
	d <- floor(log(n/(B/B1), B)) + 1
	d*n - ((B^d-1)/B1 * B/B1 - d/B1)
}

# Calculates sum(nchar(filename_for_index(i)) * i) for i in 0..(n-1), but in a
# faster way (O(log n)) than just doing the sum.
triangular_sum_filename_lengths <- Vectorize(function(n) {
	s <- 0
	m <- 1
	r <- -1
	# s is the running sum. m is the current filename length (starts at 1).
	# r keeps track of the starting point for weighting the summation in
	# each iteration; it starts at -1, not 0, because we are weighting the
	# filenames by 0:(n-1), not 1:n.
	while (n > 0) {
		# x is the number of filenames of length m: either B^m, or
		# however many remain.
		x <- min(n, B^m)
		# x * (x+1)/2 is 1 + 2 + ... + x.
		# x * ((x+1)/2 + r) is (r+1) + (r+2) + ... + (r+x).
		s <- s + m * x * ((x + 1) / 2 + r)
		# We've handled all x filenames of length m.
		n <- n - x
		# Next iteration, offset weights by the number of filenames we
		# have just processed.
		r <- r + x
		# Next filename length.
		m <- m + 1
	}
	s
})

zipped_size_given_compressed_size <- function(compressed_size, num_additional) {
	zipped_size <- 0
	zipped_size <- zipped_size + num_additional * 5 # 5 is DEFLATE quoting overhead
	zipped_size <- zipped_size + compressed_size
	zipped_size <- zipped_size + 30 * (1 + num_additional) # Local File Headers
	zipped_size <- zipped_size + 46 * (1 + num_additional) # Central Directory Headers
	zipped_size <- zipped_size + 2 * sum_filename_lengths(1 + num_additional) # Filenames in Local File Headers and Central Directory Headers
	zipped_size <- zipped_size + 22 # EOCD
	zipped_size
}

unzipped_size_given_compressed_size <- function(compressed_size, num_additional) {
	# This relies on specific knowledge of how bulk_deflate works, for
	# example that the prefix and suffix are together 16 bytes long and
	# automatically represent 1033 uncompressed bytes by themselves
	# (1+258+258 in the prefix and 258+258 in the suffix).
	unzipped_size <- 0
	unzipped_size <- unzipped_size + (1033 + (compressed_size-16) * 1032) * (1 + num_additional)
	unzipped_size <- unzipped_size + 30 * (num_additional * (num_additional + 1)) / 2
	unzipped_size <- unzipped_size + triangular_sum_filename_lengths(1 + num_additional)
	unzipped_size
}

unzipped_size_given_uncompressed_size <- function(uncompressed_size, num_additional) {
	unzipped_size <- 0
	unzipped_size <- unzipped_size + uncompressed_size * (1 + num_additional)
	unzipped_size <- unzipped_size + 30 * (num_additional * (num_additional + 1)) / 2
	unzipped_size <- unzipped_size + triangular_sum_filename_lengths(1 + num_additional)
	unzipped_size
}

additional_size <- function(num_additional) {
	num_additional * (30 + 46 + 5) + 2 * sum_filename_lengths(1 + num_additional)
}

optimize_for_zipped_size <- function(zipped_size) {
	avail <- zipped_size - 30 - 46 - 22
	num_additional <- with(list(n=0:(avail/(30+5+46))), {
		which.max(unzipped_size_given_compressed_size(avail - additional_size(n), n))
	})
	compressed_size = avail - additional_size(num_additional)
	list(compressed_size=compressed_size, num_additional=num_additional)
}

cat("\n\noptimize zbsm.zip\n");
params <- optimize_for_zipped_size(42374)
params
print(c("zipped size", zipped_size_given_compressed_size(params$compressed_size, params$num_additional)))

cat("\n\noptimize zblg.zip\n");
# 2^32 - 1 is the maximum representable file size.
# 30*65534 is the file size increase from quoting 65534 Local File Headers.
# sum_filename_lengths(65534) - sum_filename_lengths(1) is the file size increase from quoting all but the first filename.
2^32 - 1 - (30*65534 + sum_filename_lengths(65535) - sum_filename_lengths(1))
